

docker pull adminer

docker network create app-network

sudo docker run -d --name my_postgrey_app --network app-network -p 5432:5432 oscar/tp1
sudo docker run -d --name adminer --network app-network -p 8090:8080 adminer

We add to the Dockerfile
``` 
COPY ./sql-scripts/* /docker-entrypoint-initdb.d
```
then we rebuild and re run the database image.

sudo docker rm -f my_postgrey_app
sudo docker build . -t oscar/tp1
sudo docker run -d --name my_postgrey_app --network app-network -p 5432:5432 oscar/tp1

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers (like databases).
-v /my/own/datadir:/var/lib/postgresql/data

sudo docker run -d --name my_postgrey_app --network app-network --mount type=volume src=volume-tp1,target=/DevOps/tp1:/var/lib/postgresql/data -p 5432:5432 oscar/tp1

sudo docker run -d --name my-postgrey-app --network app-network -v /home/omigeon/devops/tpdocker/database:/var/lib/my-postgrey-app/data -p 5432:5432 my-postgres-db

docker run -d \
  -p "8090:8080" \
  --net=app-network \
  --name=adminer \
  adminer


sudo docker volume inspect volume-tp1
[
    {
        "CreatedAt": "2024-05-28T10:55:07+02:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/volume-tp1/_data",
        "Name": "volume-tp1",
        "Options": null,
        "Scope": "local"
    }
]

To check if the the data is well mounted, we create a teacher table in the database.

Multistage

We have to create the GreetingController class. 
path : /home/omigeon/devops/tpdocker/backend-api/simpleapi/src/main/java/fr/takima/training/simpleapi/Controller

How to integrate multistage ?
Uses a Maven image to compile the Java application.
Copies necessary files (pom.xml, src) and runs the mvn package command to build the JAR file.
Run Stage:
Uses a lighter Amazon Corretto image for running the application, reducing the final image size.
Copies the compiled JAR file from the build stage.
Sets the entry point to run the JAR file with Java.

Hy should we use multistage ?
This approach ensures a clean, minimal runtime environment with only the necessary dependencies to run the application, leading to smaller, more secure, and efficient Docker images.



http


sudo docker build -t frontend_app .
sudo docker run -d --name frontend_app -p 8082:80 --network app-network frontend_app
then localhost:8082 and we see what is written in the index.html

We end up by creating a docker-compose.yml in the src with the three container.
Docker Compose is crucial for modern application development due to its ability to manage multi-container applications efficiently, ensuring consistency, simplifying networking and dependencies, providing easy volume management, supporting multi-environment setups, allowing easy scaling, and offering a simplified command interface. This makes it a powerful tool for both development and production environments.

sudo docker compose up -d
WARN[0000] /home/omigeon/devops/tpdocker/docker-compose.yml: `version` is obsolete 
[+] Running 3/3
 ✔ Container my_postgrey_app  Started                                                                                             3.3s 
 ✔ Container backend-api      Started                                                                                             3.6s 
 ✔ Container frontend_app     Started 



 sudo docker login --username oscarepf --password *********
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded

sudo docker tag tpdocker-frontend oscarepf/tpdocker-frontend:1.0
sudo docker push oscarepf/tpdocker-frontend:1.0

TP Part02

Testcontainers:


Testcontainers is a popular library that provides lightweight, disposable instances of common databases, Selenium web browsers, and other services running in Docker containers. It's widely used for integration testing in Java applications. By using Testcontainers, developers can ensure that their tests run in environments that closely resemble production, improving the reliability and reproducibility of tests

git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/oscar92i/takima.git
git push -u origin main